stages:
  - publish
  - deploy
  - verify

.base_config: &base_config
  image: docker:25
  variables:
    DOCKER_TLS_CERTDIR: ""

build_and_push:
  <<: *base_config
  stage: publish
  tags:
    - docker
  before_script:
    - apk add --no-cache python3 py3-pip && pip install awscli --break-system-packages
    - aws ecr get-login-password --region "$AWS_DEFAULT_REGION" | docker login --username AWS --password-stdin "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com"
  script:
    - export IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
    - export REPO_URI="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPOSITORY"
    - export IMAGE_URI_TAGGED="$REPO_URI:$IMAGE_TAG"
    
    - docker build -t "$IMAGE_URI_TAGGED" .
    - docker push "$IMAGE_URI_TAGGED"
    
    - echo "IMAGE_TAG=${CI_COMMIT_SHORT_SHA}" >> build.env
  artifacts:
    reports:
      dotenv: build.env

deploy_to_ecs:
  stage: deploy
  image: 
    name: amazon/aws-cli:latest
    entrypoint: [""]
  tags:
    - docker
  needs:
    - build_and_push
  before_script:
    - yum update -y && yum install -y jq
  script:
    - set -euo pipefail

    - export REPO_URI="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPOSITORY"
    - export NEW_IMAGE_URI="$REPO_URI:$IMAGE_TAG"

    - >-
      aws ecs describe-task-definition --task-definition "$TASK_FAMILY"
      --query 'taskDefinition' > current_task_def.json

    - >-
      jq --arg IMG "$NEW_IMAGE_URI" --arg NAME "$CONTAINER_NAME" '
        (.containerDefinitions[] | select(.name == $NAME) | .image) = $IMG
        | (.containerDefinitions[] | select(.name == $NAME) | .environment) = [
          {"name":"AWS_REGION","value":env.AWS_REGION},
          {"name":"DDB_TABLE_JOBS","value":env.DDB_TABLE_JOBS},
          {"name":"USE_DYNAMODB_LOCAL","value":env.USE_DYNAMODB_LOCAL},
          {"name":"AWS_ENDPOINT_URL","value":env.AWS_ENDPOINT_URL},
          {"name":"QDRANT_URL","value":env.QDRANT_URL},
          {"name":"QDRANT_COLLECTION","value":env.QDRANT_COLLECTION},
          {"name":"APP_URL","value":env.APP_URL},
          {"name":"ENVIRONMENT","value":env.ENVIRONMENT}
        ]
        | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
      ' current_task_def.json > new_task_def.json

    - echo "âœ… Nova definiÃ§Ã£o de tarefa criada"

    - >-
      NEW_TASK_DEF_ARN=$(aws ecs register-task-definition
      --cli-input-json file://new_task_def.json
      --query 'taskDefinition.taskDefinitionArn' --output text)

    - >-
      aws ecs update-service
      --cluster "$ECS_CLUSTER"
      --service "$ECS_SERVICE"
      --task-definition "$NEW_TASK_DEF_ARN"
      --force-new-deployment > /dev/null

    - echo "âœ… Deploy para o serviÃ§o '$ECS_SERVICE' iniciado com sucesso!"

verify_deployment:
  stage: verify
  image: 
    name: amazon/aws-cli:latest
    entrypoint: [""]
  tags:
    - docker
  needs:
    - deploy_to_ecs
  script:
    - echo "â³ Aguardando o serviÃ§o '$ECS_SERVICE' estabilizar com a nova versÃ£o..."
    - >-
      aws ecs wait services-stable
      --cluster "$ECS_CLUSTER"
      --services "$ECS_SERVICE"
    
    - echo "ðŸŽ‰ ServiÃ§o '$ECS_SERVICE' estabilizado com sucesso!"
    
    - echo "âœ… Verificando status final do serviÃ§o..."
    - >-
      aws ecs describe-services
      --cluster "$ECS_CLUSTER"
      --services "$ECS_SERVICE"
      --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount}'